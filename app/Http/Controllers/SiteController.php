<?php

namespace App\Http\Controllers;

use App\Models\Site;
use Illuminate\Http\Request;

class SiteController extends Controller
{
    /**
     * عرض قائمة المواقع
     */
    public function index()
    {
        $sites = Site::orderByDesc('created_at')->get();

        return view('waf.sites.index', compact('sites'));
    }

    /**
     * عرض صفحة إضافة موقع جديد
     */
    public function create()
    {
        return view('waf.sites.create');
    }

    /**
     * حفظ موقع جديد
     */
    public function store(Request $request)
    {
        $data = $request->validate([
            'name'           => 'required|string|max:255',
            'server_name'    => 'required|string|max:255',
            'backend_ip'     => 'required|ip',
            'backend_port'   => 'required|integer|min:1|max:65535',
            'ssl_enabled'    => 'boolean',
            'ssl_cert_path'  => 'nullable|string|max:500',
            'ssl_key_path'   => 'nullable|string|max:500',
            'notes'          => 'nullable|string',
        ]);

        $data['enabled'] = true;
        $data['ssl_enabled'] = $request->has('ssl_enabled');

        $site = Site::create($data);

        // توليد ملف Nginx
        $this->generateNginxConfig($site);

        return redirect()->route('sites.index')
            ->with('status', 'تم إضافة الموقع بنجاح! يرجى إعادة تحميل Nginx.');
    }

    /**
     * حذف موقع
     */
    public function destroy(Site $site)
    {
        // حذف ملف Nginx
        $configFile = "/etc/nginx/sites-enabled/{$site->server_name}.waf.conf";
        if (file_exists($configFile)) {
            @unlink($configFile);
        }

        $site->delete();

        // إعادة تحميل Nginx
        @exec('sudo systemctl reload nginx > /dev/null 2>&1 &');

        return redirect()->route('sites.index')
            ->with('status', 'تم حذف الموقع بنجاح.');
    }

    /**
     * تفعيل/تعطيل موقع
     */
    public function toggle(Site $site)
    {
        $site->enabled = !$site->enabled;
        $site->save();

        if ($site->enabled) {
            $this->generateNginxConfig($site);
        } else {
            // حذف ملف Nginx عند التعطيل
            $configFile = "/etc/nginx/sites-enabled/{$site->server_name}.waf.conf";
            if (file_exists($configFile)) {
                @unlink($configFile);
            }
        }

        // إعادة تحميل Nginx
        @exec('sudo systemctl reload nginx > /dev/null 2>&1 &');

        return redirect()->route('sites.index')
            ->with('status', $site->enabled ? 'تم تفعيل الموقع.' : 'تم تعطيل الموقع.');
    }

    /**
     * توليد ملف Nginx Configuration
     */
    public function generateNginxConfig(Site $site): void
    {
        $configFile = "/etc/nginx/sites-enabled/{$site->server_name}.waf.conf";

        // إنشاء المحتوى
        $content = $this->buildNginxConfigContent($site);

        // كتابة الملف
        @file_put_contents($configFile, $content);

        // إعادة تحميل Nginx
        @exec('sudo systemctl reload nginx > /dev/null 2>&1 &');
    }

    /**
     * بناء محتوى ملف Nginx مع دعم السياسات الخاصة
     */
    protected function buildNginxConfigContent(Site $site): string
    {
        $backendName = str_replace('.', '_', $site->server_name) . '_backend';
        $policy = $site->policy;
        
        $content = "# Auto-generated by WAF Gateway\n";
        $content .= "# Site: {$site->name}\n";
        $content .= "# Generated at: " . now()->format('Y-m-d H:i:s') . "\n";
        $content .= "# WAF: " . ($policy && $policy->waf_enabled ? 'Enabled' : 'Disabled') . "\n";
        $content .= "# Paranoia Level: " . ($policy ? $policy->paranoia_level : 1) . "\n\n";

        // Upstream
        $content .= "upstream {$backendName} {\n";
        $content .= "    server {$site->backend_ip}:{$site->backend_port};\n";
        $content .= "}\n\n";

        // Server block
        $content .= "server {\n";
        
        if ($site->ssl_enabled && $site->ssl_cert_path && $site->ssl_key_path) {
            // HTTPS
            $content .= "    listen 443 ssl http2;\n";
            $content .= "    listen [::]:443 ssl http2;\n";
            $content .= "    server_name {$site->server_name} www.{$site->server_name};\n\n";
            
            $content .= "    # SSL Configuration\n";
            $content .= "    ssl_certificate {$site->ssl_cert_path};\n";
            $content .= "    ssl_certificate_key {$site->ssl_key_path};\n";
            $content .= "    ssl_protocols TLSv1.2 TLSv1.3;\n";
            $content .= "    ssl_ciphers HIGH:!aNULL:!MD5;\n";
            $content .= "    ssl_prefer_server_ciphers on;\n\n";
        } else {
            // HTTP
            $content .= "    listen 80;\n";
            $content .= "    listen [::]:80;\n";
            $content .= "    server_name {$site->server_name} www.{$site->server_name};\n\n";
        }

        // ModSecurity WAF Configuration
        if ($policy && $policy->waf_enabled) {
            $content .= "    # ModSecurity WAF - Enabled\n";
            $content .= "    modsecurity on;\n";
            $content .= "    modsecurity_rules_file /etc/nginx/modsec/main.conf;\n\n";
            
            // Rate Limiting
            if ($policy->rate_limiting_enabled && $policy->requests_per_minute) {
                $limitZone = str_replace('.', '_', $site->server_name) . '_limit';
                $content .= "    # Rate Limiting\n";
                $content .= "    limit_req zone={$limitZone} burst={$policy->burst_size} nodelay;\n\n";
            }
        } else {
            $content .= "    # ModSecurity WAF - Disabled\n";
            $content .= "    modsecurity off;\n\n";
        }

        // Logging
        $logLevel = $policy && $policy->detailed_logging ? 'debug' : 'warn';
        $content .= "    # Logging\n";
        $content .= "    access_log /var/log/nginx/{$site->server_name}_access.log;\n";
        $content .= "    error_log /var/log/nginx/{$site->server_name}_error.log {$logLevel};\n\n";

        // Proxy settings
        $content .= "    # Proxy to backend\n";
        $content .= "    location / {\n";
        $content .= "        proxy_pass http://{$backendName};\n";
        $content .= "        proxy_set_header Host \$host;\n";
        $content .= "        proxy_set_header X-Real-IP \$remote_addr;\n";
        $content .= "        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;\n";
        $content .= "        proxy_set_header X-Forwarded-Proto \$scheme;\n";
        $content .= "        proxy_connect_timeout 60s;\n";
        $content .= "        proxy_send_timeout 60s;\n";
        $content .= "        proxy_read_timeout 60s;\n";
        $content .= "    }\n";
        $content .= "}\n";

        // HTTP to HTTPS redirect if SSL is enabled
        if ($site->ssl_enabled && $site->ssl_cert_path && $site->ssl_key_path) {
            $content .= "\n# Redirect HTTP to HTTPS\n";
            $content .= "server {\n";
            $content .= "    listen 80;\n";
            $content .= "    listen [::]:80;\n";
            $content .= "    server_name {$site->server_name} www.{$site->server_name};\n";
            $content .= "    return 301 https://\$server_name\$request_uri;\n";
            $content .= "}\n";
        }

        // ملاحظة: نستخدم main.conf المشترك لجميع المواقع
        // يمكن لاحقاً إضافة قواعد خاصة بكل موقع إذا لزم الأمر
        
        return $content;
    }

    /**
     * توليد ملف ModSecurity خاص بالموقع
     */
    protected function generateModSecurityConfig(Site $site, $policy): void
    {
        $configFile = "/etc/nginx/modsec/{$site->server_name}.conf";
        
        $content = "# ModSecurity Configuration for {$site->name}\n";
        $content .= "# Generated at: " . now()->format('Y-m-d H:i:s') . "\n\n";

        // تضمين القواعد الأساسية (إن وجدت)
        $content .= "# Include base configuration\n";
        if (file_exists('/etc/nginx/modsec/main.conf')) {
            $content .= "Include /etc/nginx/modsec/main.conf\n\n";
        } elseif (file_exists('/etc/nginx/modsec/modsecurity.conf')) {
            $content .= "Include /etc/nginx/modsec/modsecurity.conf\n\n";
        } else {
            // إعدادات أساسية بديلة
            $content .= "SecRuleEngine On\n";
            $content .= "SecRequestBodyAccess On\n";
            $content .= "SecResponseBodyAccess Off\n";
            $content .= "SecRequestBodyLimit 13107200\n";
            $content .= "SecRequestBodyNoFilesLimit 131072\n";
            $content .= "SecRequestBodyInMemoryLimit 131072\n";
            $content .= "SecAuditEngine RelevantOnly\n";
            $content .= "SecAuditLogRelevantStatus \"^(?:5|4(?!04))\"\n";
            $content .= "SecAuditLogParts ABIJDEFHZ\n";
            $content .= "SecAuditLogType Serial\n";
            $content .= "SecAuditLog /var/log/modsec_audit.log\n";
            $content .= "SecArgumentSeparator &\n";
            $content .= "SecCookieFormat 0\n";
            $content .= "SecTmpDir /tmp/\n";
            $content .= "SecDataDir /tmp/\n\n";
        }

        // إعدادات مستوى الصرامة
        $content .= "# Paranoia Level\n";
        $content .= "SecAction \"id:900000,phase:1,nolog,pass,t:none,setvar:tx.paranoia_level={$policy->paranoia_level}\"\n\n";

        // عتبة الشذوذ
        $content .= "# Anomaly Threshold\n";
        $content .= "SecAction \"id:900110,phase:1,nolog,pass,t:none,setvar:tx.inbound_anomaly_score_threshold={$policy->anomaly_threshold}\"\n\n";

        // القواعد العامة إذا كانت وراثة القواعد مفعلة
        if ($policy->inherit_global_rules) {
            $content .= "# Global Rules\n";
            if (file_exists('/etc/nginx/modsec/global-rules.conf')) {
                $content .= "Include /etc/nginx/modsec/global-rules.conf\n\n";
            } else {
                $content .= "# Global rules file not found\n\n";
            }
        }

        // قواعد OWASP CRS (فقط إذا كانت مثبتة)
        $owaspPath = '/etc/nginx/modsec/owasp-crs/rules';
        if (is_dir($owaspPath)) {
            if ($policy->block_sql_injection && file_exists("$owaspPath/REQUEST-942-APPLICATION-ATTACK-SQLI.conf")) {
                $content .= "# OWASP CRS - SQL Injection\n";
                $content .= "Include $owaspPath/REQUEST-942-APPLICATION-ATTACK-SQLI.conf\n\n";
            }

            if ($policy->block_xss && file_exists("$owaspPath/REQUEST-941-APPLICATION-ATTACK-XSS.conf")) {
                $content .= "# OWASP CRS - XSS\n";
                $content .= "Include $owaspPath/REQUEST-941-APPLICATION-ATTACK-XSS.conf\n\n";
            }

            if ($policy->block_rce && file_exists("$owaspPath/REQUEST-932-APPLICATION-ATTACK-RCE.conf")) {
                $content .= "# OWASP CRS - RCE\n";
                $content .= "Include $owaspPath/REQUEST-932-APPLICATION-ATTACK-RCE.conf\n\n";
            }

            if ($policy->block_lfi && file_exists("$owaspPath/REQUEST-930-APPLICATION-ATTACK-LFI.conf")) {
                $content .= "# OWASP CRS - LFI\n";
                $content .= "Include $owaspPath/REQUEST-930-APPLICATION-ATTACK-LFI.conf\n\n";
            }

            if ($policy->block_rfi && file_exists("$owaspPath/REQUEST-931-APPLICATION-ATTACK-RFI.conf")) {
                $content .= "# OWASP CRS - RFI\n";
                $content .= "Include $owaspPath/REQUEST-931-APPLICATION-ATTACK-RFI.conf\n\n";
            }
        } else {
            $content .= "# OWASP CRS not installed - using basic rules only\n\n";
        }

        // استثناءات URLs
        if ($policy->excluded_urls) {
            $content .= "# Excluded URLs\n";
            foreach ($policy->excluded_urls_array as $url) {
                $url = trim($url);
                if ($url) {
                    $content .= "SecRule REQUEST_URI \"@beginsWith {$url}\" \"id:" . (800000 + crc32($url)) . ",phase:1,nolog,allow\"\n";
                }
            }
            $content .= "\n";
        }

        // استثناءات IPs
        if ($policy->excluded_ips) {
            $content .= "# Excluded IPs\n";
            foreach ($policy->excluded_ips_array as $ip) {
                $ip = trim($ip);
                if ($ip && filter_var($ip, FILTER_VALIDATE_IP)) {
                    $content .= "SecRule REMOTE_ADDR \"@ipMatch {$ip}\" \"id:" . (810000 + crc32($ip)) . ",phase:1,nolog,allow\"\n";
                }
            }
            $content .= "\n";
        }

        // قواعد مخصصة
        if ($policy->custom_modsec_rules) {
            $content .= "# Custom Rules\n";
            $content .= $policy->custom_modsec_rules . "\n\n";
        }

        // قواعد IP الخاصة بالموقع
        $content .= "# Site-specific IP Rules\n";
        
        // إنشاء ملفات IP Rules إذا لم تكن موجودة
        $sitesDir = '/etc/nginx/modsec/sites';
        if (!is_dir($sitesDir)) {
            @mkdir($sitesDir, 0755, true);
        }
        
        $whitelistFile = "$sitesDir/{$site->server_name}-whitelist.txt";
        $blacklistFile = "$sitesDir/{$site->server_name}-blacklist.txt";
        
        if (!file_exists($whitelistFile)) {
            @file_put_contents($whitelistFile, "# Whitelist for {$site->name}\n");
        }
        if (!file_exists($blacklistFile)) {
            @file_put_contents($blacklistFile, "# Blacklist for {$site->name}\n");
        }
        
        if (file_exists($whitelistFile)) {
            $content .= "Include $whitelistFile\n";
        }
        if (file_exists($blacklistFile)) {
            $content .= "Include $blacklistFile\n";
        }

        @file_put_contents($configFile, $content);
    }

    /**
     * إعادة توليد جميع ملفات Nginx
     */
    public function regenerateAll()
    {
        $sites = Site::where('enabled', true)->get();

        foreach ($sites as $site) {
            $this->generateNginxConfig($site);
        }

        return redirect()->route('sites.index')
            ->with('status', 'تم إعادة توليد جميع ملفات المواقع بنجاح.');
    }
}
